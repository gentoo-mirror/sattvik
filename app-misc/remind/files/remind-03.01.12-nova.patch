diff -Naur remind-03.01.12.orig/src/custom.h remind-03.01.12/src/custom.h
--- remind-03.01.12.orig/src/custom.h	2012-01-23 12:08:37.000000000 -0600
+++ remind-03.01.12/src/custom.h	2012-02-02 05:39:29.000000000 -0600
@@ -29,6 +29,9 @@
 #define LON_MIN 39
 #define LON_SEC  0
 #define LOCATION "Ottawa"
+#define LOC_ALT  0
+#define LOC_PRESSURE  1010
+#define LOC_TEMP  10
 
 /*---------------------------------------------------------------------*/
 /* DEFAULT_PAGE:  The default page size to use for Rem2PS.             */
diff -Naur remind-03.01.12.orig/src/funcs.c remind-03.01.12/src/funcs.c
--- remind-03.01.12.orig/src/funcs.c	2012-01-12 12:12:55.000000000 -0600
+++ remind-03.01.12/src/funcs.c	2012-02-02 05:39:29.000000000 -0600
@@ -48,6 +48,7 @@
 #include "protos.h"
 #include "err.h"
 #include "expr.h"
+#include "nova.h"
 
 /* Defines that used to be static variables */
 #define Nargs (info->nargs)
@@ -97,8 +98,12 @@
 static	int	FMinsfromutc	(func_info *);
 static	int	FMoondate	(func_info *);
 static	int	FMoondatetime	(func_info *);
+static	int	FMoonillum   	(func_info *);
 static	int	FMoonphase	(func_info *);
+static	int	FMoonrise 	(func_info *);
+static	int	FMoonset  	(func_info *);
 static	int	FMoontime	(func_info *);
+static	int	FMoontransit 	(func_info *);
 static	int	FMon		(func_info *);
 static	int	FMonnum		(func_info *);
 static	int	FOrd		(func_info *);
@@ -114,6 +119,7 @@
 static	int	FDusk	 	(func_info *);
 static	int	FSunset		(func_info *);
 static	int	FSunrise	(func_info *);
+static	int	FSuntransit	(func_info *);
 static	int	FTime		(func_info *);
 static	int	FTrigdate	(func_info *);
 static	int	FTrigdatetime	(func_info *);
@@ -231,8 +237,12 @@
     {   "monnum",       1,      1,      1,          FMonnum },
     {   "moondate",     1,      3,      0,          FMoondate },
     {   "moondatetime", 1,      3,      0,          FMoondatetime },
+    {	"moonillum",    0,      2,      0,          FMoonillum },
     {   "moonphase",    0,      2,      0,          FMoonphase },
+    {   "moonrise",     0,      1,      0,          FMoonrise },
+    {   "moonset",      0,      1,      0,          FMoonset },
     {   "moontime",     1,      3,      0,          FMoontime },
+    {   "moontransit",  0,      1,      0,          FMoontransit },
     {   "nonomitted",   2,      NO_MAX, 0,          FNonomitted },
     {   "now",          0,      0,      0,          FNow    },
     {   "ord",          1,      1,      1,          FOrd    },
@@ -250,6 +260,7 @@
     {   "substr",       2,      3,      1,          FSubstr },
     {   "sunrise",      0,      1,      0,          FSunrise},
     {   "sunset",       0,      1,      0,          FSunset },
+    {   "suntransit",   0,      1,      0,          FSuntransit },
     {   "time",         2,      2,      1,          FTime   },
     {   "timepart",     1,      1,      1,          FTimepart },
     {   "today",        0,      0,      0,          FToday  },
@@ -2000,7 +2011,27 @@
 	jul = DATEPART(ARG(0));
     }
 
-    r = SunStuff(rise, cosz, jul);
+    switch(rise) {
+      case 0: /* sunset */
+	r=novaSunset(jul);
+	break;
+      case 1: /* sunrise */
+	r=novaSunrise(jul);
+	break;
+      case 2: /* dusk */
+	r=novaDusk(jul);
+	break;
+      case 3: /* dawn */
+	r=novaDawn(jul);
+	break;
+      case 4: /* Sun's transit */
+	r=novaSuntransit(jul);
+	break;
+      default:
+	r = SunStuff(rise, cosz, jul);
+	break;
+    }
+
     if (r == NO_TIME) {
 	RETVAL = 0;
 	RetVal.type = INT_TYPE;
@@ -2022,6 +2053,10 @@
 {
     return FSun(0, info);
 }
+static int FSuntransit(func_info *info)
+{
+    return FSun(4, info);
+}
 
 static int FDawn(func_info *info)
 {
@@ -2275,6 +2310,158 @@
 }
 
 /***************************************************************/
+/*                                                             */
+/*  FMoonillum                                                 */
+/*                                                             */
+/*  Moon's illumination for specified date/time.               */
+/*                                                             */
+/***************************************************************/
+static int FMoonillum(func_info *info)
+{
+    int date, time;
+
+    switch(Nargs) {
+    case 0:
+	date = JulianToday;
+	time = 0;
+	break;
+    case 1:
+	if (ARG(0).type != DATE_TYPE) return E_BAD_TYPE;
+	date = ARG(0).v.val;
+	time = 0;
+	break;
+    case 2:
+	if (ARG(0).type != DATE_TYPE && ARG(1).type != TIME_TYPE) return E_BAD_TYPE;
+	date = ARG(0).v.val;
+	time = ARG(1).v.val;
+	break;
+
+    default: return E_SWERR;
+    }
+
+    RetVal.type = INT_TYPE;
+    RetVal.v.val = novaMoonIllumination(date, time);
+    return OK;
+}
+
+/***************************************************************/
+/*                                                             */
+/*  FMoonrise                                                  */
+/*                                                             */
+/*  Time of the moonrise for a given date.                     */
+/*                                                             */
+/***************************************************************/
+static int FMoonrise(func_info *info)
+{
+  int time;
+  int jul = JulianToday;
+  if(Nargs >= 1) {
+    if(ARG(0).type != DATE_TYPE) {
+      return E_BAD_TYPE;
+    }
+    jul = ARG(0).v.val;
+  }
+  time=novaMoonrise(jul);
+  switch(time) {
+    case NO_TIME:
+      RetVal.type = INT_TYPE;
+      RetVal.v.val = 0;
+      break;
+    case -NO_TIME:
+      RetVal.type = INT_TYPE;
+      RetVal.v.val = 1440;
+      break;
+    case -1:
+      RetVal.type = INT_TYPE;
+      RetVal.v.val = -1;
+      break;
+    default:
+      RetVal.type = TIME_TYPE;
+      RetVal.v.val = time;
+      break;
+  }
+  return OK;
+}
+
+/***************************************************************/
+/*                                                             */
+/*  FMoonset                                                   */
+/*                                                             */
+/*  Time of the moonset for a given date.                      */
+/*                                                             */
+/***************************************************************/
+static int FMoonset(func_info *info)
+{
+  int time;
+  int jul = JulianToday;
+  if(Nargs >= 1) {
+    if(ARG(0).type != DATE_TYPE) {
+      return E_BAD_TYPE;
+    }
+    jul = ARG(0).v.val;
+  }
+  time=novaMoonset(jul);
+  switch(time) {
+    case NO_TIME:
+      RetVal.type = INT_TYPE;
+      RetVal.v.val = 0;
+      break;
+    case -NO_TIME:
+      RetVal.type = INT_TYPE;
+      RetVal.v.val = 1440;
+      break;
+    case -1:
+      RetVal.type = INT_TYPE;
+      RetVal.v.val = -1;
+      break;
+    default:
+      RetVal.type = TIME_TYPE;
+      RetVal.v.val = time;
+      break;
+  }
+  return OK;
+}
+
+/***************************************************************/
+/*                                                             */
+/*  FMoontransit                                               */
+/*                                                             */
+/*  Time of the moon's transit for a given date.               */
+/*                                                             */
+/***************************************************************/
+static int FMoontransit(func_info *info)
+{
+  int time;
+  int jul = JulianToday;
+  if(Nargs >= 1) {
+    if(ARG(0).type != DATE_TYPE) {
+      return E_BAD_TYPE;
+    }
+    jul = ARG(0).v.val;
+  }
+  time=novaMoontransit(jul);
+  switch(time) {
+    case NO_TIME:
+      RetVal.type = INT_TYPE;
+      RetVal.v.val = 0;
+      break;
+    case -NO_TIME:
+      RetVal.type = INT_TYPE;
+      RetVal.v.val = 1440;
+      break;
+    case -1:
+      RetVal.type = INT_TYPE;
+      RetVal.v.val = -1;
+      break;
+    default:
+      RetVal.type = TIME_TYPE;
+      RetVal.v.val = time;
+      break;
+  }
+  return OK;
+}
+
+/***************************************************************/
 /*                                                             */
 /*  FMoondate                                                  */
 /*                                                             */
diff -Naur remind-03.01.12.orig/src/globals.h remind-03.01.12/src/globals.h
--- remind-03.01.12.orig/src/globals.h	2010-09-10 09:20:07.000000000 -0500
+++ remind-03.01.12/src/globals.h	2012-02-02 05:39:29.000000000 -0600
@@ -107,6 +107,9 @@
 EXTERN  INIT(	int	  LongMin, LON_MIN);
 EXTERN  INIT(	int	  LongSec, LON_SEC);
 EXTERN	INIT(	char	  *Location, LOCATION);
+EXTERN  INIT(	int	  LocationAlt, LOC_ALT);
+EXTERN  INIT(	int	  LocationPressure, LOC_PRESSURE);
+EXTERN  INIT(	int	  LocationTemp, LOC_TEMP);
 
 /* UTC calculation stuff */
 EXTERN  INIT(	int	  MinsFromUTC, 0);
diff -Naur remind-03.01.12.orig/src/Makefile.in remind-03.01.12/src/Makefile.in
--- remind-03.01.12.orig/src/Makefile.in	2012-01-23 10:13:46.000000000 -0600
+++ remind-03.01.12/src/Makefile.in	2012-02-02 05:39:29.000000000 -0600
@@ -29,10 +29,10 @@
 
 REMINDSRCS=	calendar.c dynbuf.c dorem.c dosubst.c expr.c files.c funcs.c \
 		globals.c hbcal.c init.c main.c md5.c moon.c omit.c queue.c \
-		sort.c token.c trigger.c userfns.c utils.c var.c
+		sort.c token.c trigger.c userfns.c utils.c var.c nova.c
 
 REMINDHDRS=config.h custom.h dynbuf.h err.h expr.h globals.h lang.h \
-	   md5.h protos.h rem2ps.h types.h version.h
+	   md5.h protos.h rem2ps.h types.h version.h nova.h
 REMINDOBJS= $(REMINDSRCS:.c=.o)
 
 all: remind rem2ps
@@ -47,7 +47,7 @@
 	@CC@ @LDFLAGS@ $(LDEXTRA) -o rem2ps rem2ps.o dynbuf.o
 
 remind: $(REMINDOBJS)
-	@CC@ @LDFLAGS@ $(LDEXTRA) -o remind $(REMINDOBJS) @LIBS@
+	@CC@ @LDFLAGS@ $(LDEXTRA) -o remind $(REMINDOBJS) -lnova @LIBS@
 
 install-nostripped: all
 	-mkdir -p $(DESTDIR)$(bindir) || true
diff -Naur remind-03.01.12.orig/src/nova.c remind-03.01.12/src/nova.c
--- remind-03.01.12.orig/src/nova.c	1969-12-31 18:00:00.000000000 -0600
+++ remind-03.01.12/src/nova.c	2012-02-02 05:39:29.000000000 -0600
@@ -0,0 +1,580 @@
+#include "config.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include <time.h>
+#include "types.h"
+#include "protos.h"
+#include "expr.h"
+#include "globals.h"
+#include "err.h"
+#include <libnova/libnova.h>
+#include "nova.h"
+
+#define SIDRATE         .9972695677
+#define KM_PER_AU       149598000
+
+int lastMoonSetDate=-1;
+int lastMoonSetTime=0;
+int lastMoonRiseDate=-1;
+int lastMoonRiseTime=0;
+int lastMoonTransitDate=-1;
+int lastMoonTransitTime=0;
+int lastSunSetDate=-1;
+int lastSunSetTime=0;
+int lastSunRiseDate=-1;
+int lastSunRiseTime=0;
+int lastSunTransitDate=-1;
+int lastSunTransitTime=0;
+int lastDawnDate=-1;
+int lastDawnTime=0;
+int lastDuskDate=-1;
+int lastDuskTime=0;
+
+typedef void (*CoordFunction)(double,struct ln_equ_posn*);
+typedef double (*DistanceFunction)(double);
+typedef double (*SemiDiamFunction)(double);
+
+double solarDistance(double JD)
+{
+  return ln_get_earth_solar_dist(JD)*KM_PER_AU;
+}
+
+int find0alt(double dt,double hrz,double*JD,struct ln_lnlat_posn*obs,
+    CoordFunction get_equ_body_coords,DistanceFunction distance,
+    SemiDiamFunction semidiameter)
+{
+  double origJD=*JD;
+  double a0=0;
+  struct ln_equ_posn pos;
+  struct ln_hrz_posn hrzPos;
+  int npasses=0;
+  if(dt<=-12.0 && !find0alt(dt+24.0,hrz,JD,obs,get_equ_body_coords,distance,
+	semidiameter)) {
+    return 0;
+  }
+  *JD=origJD;
+  if(dt>=12.0 && !find0alt(dt-24.0,hrz,JD,obs,get_equ_body_coords,distance,
+	semidiameter)) {
+    return 0;
+  }
+  *JD=origJD;
+  dt/=24.0;
+  *JD+=dt;
+  get_equ_body_coords(*JD, &pos);
+  ln_get_hrz_from_equ(&pos,obs,*JD,&hrzPos);
+  a0=hrzPos.alt-hrz;
+  dt=1.0/60.0/24.0;
+  do {
+    double JD2=*JD+dt;
+    get_equ_body_coords(JD2, &pos);
+    struct ln_hrz_posn hrzPos2;
+    ln_get_hrz_from_equ(&pos,obs,JD2,&hrzPos2);
+    struct ln_equ_posn parallax;
+    double ld=distance(JD2)/KM_PER_AU;
+    ln_get_parallax(&pos,ld,obs,10.0,JD2,&parallax);
+    pos.ra+=parallax.ra;
+    pos.dec+=parallax.dec;
+    ln_get_hrz_from_equ(&pos,obs,JD2,&hrzPos);
+    double sd=semidiameter(JD2)/3600.0;
+    double ref=ln_get_refraction_adj(hrz,1010.,10.);
+    double a1=hrz-hrzPos.alt-sd-ref;
+    dt=-a1*(JD2-*JD)/(a1-a0);
+    *JD=JD2;
+    a0=a1;
+  } while(++npasses<20 && fabs(dt)>1./3600./24.);
+  if(npasses==20) {
+    return -3;
+  }
+  return (fabs(*JD-origJD)<0.5) ? 0 : -2;
+}
+
+int findBodySet(double JD,struct ln_lnlat_posn*observer,
+    CoordFunction get_equ_body_coords,DistanceFunction distance,
+    SemiDiamFunction semidiameter,double horizont,double*setJD)
+{
+  double gast,last;
+  double deltaT;
+  double H0,H1;
+  double transitHA;
+  double setHA;
+  struct ln_equ_posn pos;
+  struct ln_hrz_posn hrzPos;
+
+  /* dynamical time diff */
+  deltaT=ln_get_dynamical_time_diff(JD)/86400.0;
+  /* adjust time */
+  JD+=deltaT;
+  /* get greenwich apparent sidereal time */
+  gast=ln_get_apparent_sidereal_time(JD);
+  gast*=15.0;
+  /* convert to local apparente sidereal time */
+  last=gast+observer->lng;
+  /* get position at local noon */
+  get_equ_body_coords(JD, &pos);
+  ln_get_hrz_from_equ(&pos,observer,JD,&hrzPos);
+  /* compute local hour angle */
+  H0=sin(ln_deg_to_rad(horizont))-
+    sin(ln_deg_to_rad(observer->lat))*sin(ln_deg_to_rad (pos.dec));
+  H1=cos(ln_deg_to_rad(observer->lat))*cos(ln_deg_to_rad (pos.dec));
+  H1=H0/H1;
+  /* check if body is circumpolar */
+  if(H1>=1.0) {
+    /* never sets */
+    return 1;
+  }
+  else if(H1 <= -1.0) {
+    /* never rises */
+    return -1;
+  }
+  /* get the final local hour angle */
+  H0=ln_rad_to_deg(acos(H1));
+  transitHA=pos.ra-last;
+  setHA=transitHA+H0;
+  setHA=pos.ra+H0;
+  *setJD=JD;
+  setHA-=360.0*floor(setHA/360.0);
+  return find0alt((setHA-last)/15.0/SIDRATE,horizont,setJD,observer,
+      get_equ_body_coords,distance,semidiameter);
+}
+
+int findBodyRise(double JD,struct ln_lnlat_posn*observer,
+    CoordFunction get_equ_body_coords,DistanceFunction distance,
+    SemiDiamFunction semidiameter,double horizont,double*riseJD)
+{
+  double gast,last;
+  double deltaT;
+  double H0,H1;
+  double riseHA;
+  struct ln_equ_posn pos;
+  struct ln_hrz_posn hrzPos;
+
+  /* dynamical time diff */
+  deltaT=ln_get_dynamical_time_diff(JD)/86400.0;
+  /* adjust time */
+  JD+=deltaT;
+  /* get greenwich apparent sidereal time */
+  gast=ln_get_apparent_sidereal_time(JD);
+  gast*=15.0;
+  /* convert to local apparent sidereal time */
+  last=gast+observer->lng;
+  /* get position at local noon */
+  get_equ_body_coords(JD, &pos);
+  ln_get_hrz_from_equ(&pos,observer,JD,&hrzPos);
+
+  /* compute local hour angle */
+  H0=sin(ln_deg_to_rad(horizont))-
+    sin(ln_deg_to_rad(observer->lat))*sin(ln_deg_to_rad (pos.dec));
+  H1=cos(ln_deg_to_rad(observer->lat))*cos(ln_deg_to_rad (pos.dec));
+  H1=H0/H1;
+  /* check if body is circumpolar */
+  if(H1>=1.0) {
+    /* never sets */
+    return 1;
+  }
+  else if(H1 <= -1.0) {
+    /* never rises */
+    return -1;
+  }
+  /* get the final local hour angle */
+  H0=ln_rad_to_deg(acos(H1));
+  riseHA=pos.ra-H0;
+  *riseJD=JD;
+  riseHA-=360.0*floor(riseHA/360.0);
+  return find0alt((riseHA-last)/15.0/SIDRATE,horizont,riseJD,observer,
+      get_equ_body_coords,distance,semidiameter);
+}
+
+int findTransit(double dt,double*JD,struct ln_lnlat_posn*obs,
+    CoordFunction get_equ_body_coords)
+{
+  double origJD=*JD;
+  struct ln_equ_posn pos;
+  int npasses=0;
+  if(dt<-12.0) {
+    dt+=24.0;
+  }
+  else if(dt>12.0) {
+    dt-=24.0;
+  }
+  do {
+    *JD+=dt/24.0;
+    /* get greenwich apparent sidereal time */
+    double gast=ln_get_apparent_sidereal_time(*JD);
+    gast*=15.0;
+    /* convert to local apparente sidereal time */
+    double last=gast+obs->lng;
+    get_equ_body_coords(*JD,&pos);
+    dt=(pos.ra-last)/15.0/SIDRATE;
+    if(dt<=-12.0) dt+=24.0;
+    if(dt>=12.0) dt-=24.0;
+  } while(++npasses<20 && fabs(dt)>1.0/60.0);
+  if(npasses==20) {
+    return -3;
+  }
+  return (fabs(*JD-origJD)<0.5) ? 0 : -2;
+}
+
+int findBodyTransit(double JD,struct ln_lnlat_posn*observer,void (*get_equ_body_coords)(double,struct ln_equ_posn*),double*outJD)
+{
+  double gast,last;
+  double deltaT;
+  double transitHA;
+  struct ln_equ_posn pos;
+
+  /* dynamical time diff */
+  deltaT=ln_get_dynamical_time_diff(JD)/86400.0;
+  /* adjust time */
+  JD+=deltaT;
+  /* get greenwich apparent sidereal time */
+  gast=ln_get_apparent_sidereal_time(JD);
+  gast*=15.0;
+  /* convert to local apparente sidereal time */
+  last=gast+observer->lng;
+  /* get position at local noon */
+  get_equ_body_coords(JD, &pos);
+  transitHA=pos.ra-last;
+  *outJD=JD;
+  return findTransit((transitHA-last)/15.0/SIDRATE,outJD,observer,
+      get_equ_body_coords);
+}
+
+double Remind2Julian(int date,int time)
+{
+  int utcd,utct;
+  int y,m,d;
+  struct ln_date utcDate;
+  /* Convert from local time to UTC */
+  LocalToUTC(date, time, &utcd, &utct);
+  /* Convert from Remind representation to year/mon/day */
+  FromJulian(utcd, &y, &m, &d);
+  /* get actual julian day */
+  utcDate.years=y;
+  utcDate.months=m+1;
+  utcDate.days=d;
+  utcDate.hours=utct/60;
+  utcDate.minutes=utct%60;
+  utcDate.seconds=0.0;
+  /* Convert to Julian. */
+  return ln_get_julian_day(&utcDate);
+}
+
+void Julian2Remind(double jul,int*date,int*time)
+{
+  int utcd,utct;
+  struct ln_date utcDate;
+  /* Get UTC from Julian. */
+  ln_get_date(jul,&utcDate);
+  /* Get Remind's version of a UTC date. */
+  utcd=Julian(utcDate.years,utcDate.months-1,utcDate.days);
+  /* Get Remind's version of a UTC time. */
+  utct=utcDate.hours*60+utcDate.minutes+((utcDate.seconds>=30.0) ? 1 : 0);
+  if(utct==0 && utcDate.hours==23) {
+    utct=23*60+59;
+  }
+  /* Convert from UTC to local time. */
+  UTCToLocal(utcd,utct,date,time);
+}
+
+struct ln_lnlat_posn getObserver(void)
+{
+  struct ln_lnlat_posn obs;
+  /* set observer */
+  obs.lat=(double)LatDeg+(double)LatMin/60.0+(double)LatSec/3600.0;
+  obs.lng=(double)-LongDeg+(double)LongMin/60.0+(double)LongSec/3600.0;
+  return obs;
+}
+
+int novaSunrise(int date)
+{
+  struct ln_lnlat_posn observer=getObserver();
+  struct ln_rst_time rst;
+  double julDate;
+  int time;
+
+  if(lastSunRiseDate==date) {
+    return lastSunRiseTime;
+  }
+
+  /* get julian day for today at noon. */
+  julDate=Remind2Julian(date,12*60);
+  /* calculate solar rise/set/transit. */
+  switch(ln_get_solar_rst(julDate,&observer,&rst)) {
+    case 1:
+      /* Perpetual dawn. */
+      lastSunRiseTime=NO_TIME;
+      break;
+    case -1:
+      /* Sunless day. */
+      lastSunRiseTime=-NO_TIME;
+      break;
+    default:
+      /* convert julian day to remind local time */
+      Julian2Remind(rst.rise,&date,&time);
+      lastSunRiseTime=time;
+      break;
+  }
+  lastSunRiseDate=date;
+  return lastSunRiseTime;
+}
+
+int novaSunset(int date)
+{
+  struct ln_lnlat_posn observer=getObserver();
+  struct ln_rst_time rst;
+  double julDate;
+  int time;
+
+  if(lastSunSetDate==date) {
+    return lastSunSetTime;
+  }
+
+  /* get julian day for today at noon. */
+  julDate=Remind2Julian(date,12*60);
+  /* calculate solar rise/set/transit. */
+  switch(ln_get_solar_rst(julDate,&observer,&rst)) {
+    case 1:
+      /* Perpetual dawn. */
+      lastSunSetTime=NO_TIME;
+      break;
+    case -1:
+      /* Sunless day. */
+      lastSunSetTime=-NO_TIME;
+      break;
+    default:
+      /* convert julian day to remind local time */
+      Julian2Remind(rst.set,&date,&time);
+      lastSunSetTime=time;
+      break;
+  }
+  lastSunSetDate=date;
+  return lastSunSetTime;
+}
+
+int novaSuntransit(int date)
+{
+  struct ln_lnlat_posn observer=getObserver();
+  struct ln_rst_time rst;
+  double julDate;
+  int time;
+
+  if(lastSunTransitDate==date) {
+    return lastSunTransitTime;
+  }
+
+  /* get julian day for today at noon. */
+  julDate=Remind2Julian(date,12*60);
+  /* calculate solar rise/set/transit. */
+  switch(ln_get_solar_rst(julDate,&observer,&rst)) {
+    case 1:
+      /* Perpetual dawn. */
+      lastSunTransitTime=NO_TIME;
+      break;
+    case -1:
+      /* Sunless day. */
+      lastSunTransitTime=-NO_TIME;
+      break;
+    default:
+      /* convert julian day to remind local time */
+      Julian2Remind(rst.transit,&date,&time);
+      lastSunTransitTime=time;
+      break;
+  }
+  lastSunTransitDate=date;
+  return lastSunTransitTime;
+}
+
+int novaDawn(int date)
+{
+  struct ln_lnlat_posn observer=getObserver();
+  struct ln_rst_time rst;
+  double julDate;
+  int time;
+  if(lastDawnDate==date) {
+    return lastDawnTime;
+  }
+  /* get julian day for today at noon. */
+  julDate=Remind2Julian(date,12*60);
+  /* calculate solar rise/set/transit. */
+  switch(ln_get_solar_rst_horizon(julDate,&observer,
+	LN_SOLAR_CIVIL_HORIZON,&rst)) {
+    case 1:
+      /* Perpetual dawn. */
+      lastDawnTime=NO_TIME;
+      break;
+    case -1:
+      /* Sunless day. */
+      lastDawnTime=-NO_TIME;
+      break;
+    default:
+      /* convert julian day to remind local time */
+      Julian2Remind(rst.rise,&date,&time);
+      lastDawnTime=time;
+      break;
+  }
+  lastDawnDate=date;
+  return lastDawnTime;
+}
+
+int novaDusk(int date)
+{
+  struct ln_lnlat_posn observer=getObserver();
+  struct ln_rst_time rst;
+  double julDate;
+  int time;
+
+  if(lastDuskDate==date) {
+    return lastDuskTime;
+  }
+
+  /* get julian day for today at noon. */
+  julDate=Remind2Julian(date,12*60);
+  /* calculate solar rise/set/transit. */
+  switch(ln_get_solar_rst_horizon(julDate,&observer,
+	LN_SOLAR_CIVIL_HORIZON,&rst)) {
+    case 1:
+      /* Perpetual dawn. */
+      lastDuskTime=NO_TIME;
+      break;
+    case -1:
+      /* Sunless day. */
+      lastDuskTime=-NO_TIME;
+      break;
+    default:
+      /* convert julian day to remind local time */
+      Julian2Remind(rst.set,&date,&time);
+      lastDuskTime=time;
+      break;
+  }
+  lastDuskDate=date;
+  return lastDuskTime;
+}
+
+int novaMoonrise(int date)
+{
+  struct ln_lnlat_posn observer=getObserver();
+  double julDate;
+  double riseJD;
+  int time;
+  int ret;
+
+  if(date==lastMoonRiseDate) {
+    return lastMoonRiseTime;
+  }
+
+  /* get julian day for today at noon. */
+  julDate=Remind2Julian(date,12*60);
+  /* calculate lunar rise/set/transit. */
+  ret=findBodyRise(julDate,&observer,ln_get_lunar_equ_coords,
+      ln_get_lunar_earth_dist,ln_get_lunar_sdiam,0.0,&riseJD);
+  switch(ret) {
+    case 1:
+      /* All day moon. */
+      lastMoonRiseTime=NO_TIME;
+      break;
+    case -1:
+      /* Moonless day. */
+      lastMoonRiseTime=-NO_TIME;
+      break;
+    case -2:
+    case -3:
+      /* not today */
+      lastMoonRiseTime=-1;
+      break;
+    default:
+      /* convert julian day to remind local time */
+      Julian2Remind(riseJD,&date,&time);
+      lastMoonRiseTime=time;
+  }
+  lastMoonRiseDate=date;
+  return lastMoonRiseTime;
+}
+
+int novaMoonset(int date)
+{
+  struct ln_lnlat_posn observer=getObserver();
+  double julDate;
+  double setJD;
+  int time;
+  int ret;
+
+  if(date==lastMoonSetDate) {
+    return lastMoonSetTime;
+  }
+  /* get julian day for today at noon. */
+  julDate=Remind2Julian(date,12*60);
+  /* calculate lunar rise/set/transit. */
+  ret=findBodySet(julDate,&observer,ln_get_lunar_equ_coords,
+      ln_get_lunar_earth_dist,ln_get_lunar_sdiam,0.0,&setJD);
+  switch(ret) {
+    case 1:
+      /* All day moon. */
+      lastMoonSetTime=NO_TIME;
+      break;
+    case -1:
+      /* Moonless day. */
+      lastMoonSetTime=-NO_TIME;
+      break;
+    case -2:
+    case -3:
+      /* not today */
+      lastMoonSetTime=-1;
+      break;
+    default:
+      /* convert julian day to remind local time */
+      Julian2Remind(setJD,&date,&time);
+      lastMoonSetTime=time;
+  }
+  lastMoonSetDate=date;
+  return lastMoonSetTime;
+}
+
+int novaMoontransit(int date)
+{
+  struct ln_lnlat_posn observer=getObserver();
+  double julDate;
+  double outJD;
+  int time;
+  int ret;
+  if(date==lastMoonTransitDate) {
+    return lastMoonTransitTime;
+  } // if
+
+  /* get julian day for today at noon. */
+  julDate=Remind2Julian(date,12*60);
+  /* calculate lunar rise/set/transit. */
+  ret=findBodyTransit(julDate,&observer,ln_get_lunar_equ_coords,&outJD);
+  switch(ret) {
+    case 1:
+      /* All day moon. */
+      lastMoonTransitTime=NO_TIME;
+      break;
+    case -1:
+      /* Moonless day. */
+      lastMoonTransitTime=-NO_TIME;
+      break;
+    case -2:
+    case -3:
+      /* not today */
+      lastMoonTransitTime=-1;
+      break;
+    default:
+      /* convert julian day to remind local time */
+      Julian2Remind(outJD,&date,&time);
+      lastMoonTransitTime=time;
+      break;
+  }
+  lastMoonTransitDate=date;
+  return lastMoonTransitTime;
+}
+
+int novaMoonIllumination(int date,int time)
+{
+  double julDate;
+  double pctIllum;
+  /* get julian day for the date and time */
+  julDate=Remind2Julian(date,time);
+  pctIllum=ln_get_lunar_disk(julDate);
+
+  return (int)(pctIllum*100.0);
+}
diff -Naur remind-03.01.12.orig/src/nova.h remind-03.01.12/src/nova.h
--- remind-03.01.12.orig/src/nova.h	1969-12-31 18:00:00.000000000 -0600
+++ remind-03.01.12/src/nova.h	2012-02-02 05:39:29.000000000 -0600
@@ -0,0 +1,9 @@
+int novaSunrise(int date);
+int novaSuntransit(int date);
+int novaSunset(int date);
+int novaDawn(int date);
+int novaDusk(int date);
+int novaMoonrise(int);
+int novaMoonset(int);
+int novaMoontransit(int);
+int novaMoonIllumination(int,int);
diff -Naur remind-03.01.12.orig/src/var.c remind-03.01.12/src/var.c
--- remind-03.01.12.orig/src/var.c	2010-04-21 12:16:14.000000000 -0500
+++ remind-03.01.12/src/var.c	2012-02-02 05:39:29.000000000 -0600
@@ -592,6 +592,9 @@
     {"LatMin",         1,  INT_TYPE,     &LatMin,             -59,    59  },
     {"LatSec",         1,  INT_TYPE,     &LatSec,             -59,    59  },
     {"Location",       1,  STR_TYPE,     &Location,           0,      0   },
+    {"LocationAlt",    1,  INT_TYPE,     &LocationAlt         ANY,    ANY },
+    {"LocationPressure",1, INT_TYPE,     &LocationPressure,   0,      ANY },
+    {"LocationTemp",   1,  INT_TYPE,     &LocationTemp,       ANY,    ANY },
     {"LongDeg",        1,  INT_TYPE,     &LongDeg,            -180,   180 },
     {"LongMin",        1,  INT_TYPE,     &LongMin,            -59,    59  },
     {"LongSec",        1,  INT_TYPE,     &LongSec,            -59,    59  },
